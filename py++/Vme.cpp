// This file has been generated by Py++.

#include "boost/python.hpp"

#include "__array_1.pypp.hpp"

#include "/Users/gchristian/soft/develop/dragon/analyzer/src/vme/IO32.hxx"

#include "/Users/gchristian/soft/develop/dragon/analyzer/src/vme/V1190.hxx"

#include "/Users/gchristian/soft/develop/dragon/analyzer/src/vme/V792.hxx"

namespace bp = boost::python;

struct V1190_wrapper : vme::V1190, bp::wrapper< vme::V1190 > {

    V1190_wrapper(vme::V1190 const & arg )
    : vme::V1190( arg )
      , bp::wrapper< vme::V1190 >(){
        // copy constructor
        
    }

    struct Channel_wrapper : vme::V1190::Channel, bp::wrapper< vme::V1190::Channel > {
    
        Channel_wrapper(vme::V1190::Channel const & arg )
        : vme::V1190::Channel( arg )
          , bp::wrapper< vme::V1190::Channel >(){
            // copy constructor
            
        }
    
        Channel_wrapper()
        : vme::V1190::Channel()
          , bp::wrapper< vme::V1190::Channel >(){
            // null constructor
            
        }
    
        static pyplusplus::containers::static_sized::array_1_t< int, 5>
        pyplusplus_leading_edge_wrapper( ::vme::V1190::Channel & inst ){
            return pyplusplus::containers::static_sized::array_1_t< int, 5>( inst.leading_edge );
        }
    
        static pyplusplus::containers::static_sized::array_1_t< int, 5>
        pyplusplus_trailing_edge_wrapper( ::vme::V1190::Channel & inst ){
            return pyplusplus::containers::static_sized::array_1_t< int, 5>( inst.trailing_edge );
        }
    
    };

    V1190_wrapper( )
    : vme::V1190( )
      , bp::wrapper< vme::V1190 >(){
        // null constructor
    
    }

    static pyplusplus::containers::static_sized::array_1_t< ::vme::V1190::Channel, 64>
    pyplusplus_channel_wrapper( ::vme::V1190 & inst ){
        return pyplusplus::containers::static_sized::array_1_t< ::vme::V1190::Channel, 64>( inst.channel );
    }

};

struct V792_wrapper : vme::V792, bp::wrapper< vme::V792 > {

    V792_wrapper(vme::V792 const & arg )
    : vme::V792( arg )
      , bp::wrapper< vme::V792 >(){
        // copy constructor
        
    }

    V792_wrapper( )
    : vme::V792( )
      , bp::wrapper< vme::V792 >(){
        // null constructor
    
    }

    static pyplusplus::containers::static_sized::array_1_t< short int, 32>
    pyplusplus_data_wrapper( ::vme::V792 & inst ){
        return pyplusplus::containers::static_sized::array_1_t< short int, 32>( inst.data );
    }

};

#include "Headers.hpp"

#include "Constants.hpp"

BOOST_PYTHON_MODULE(vme){
    bp::class_< vme::IO32 >( "IO32", bp::init< >() )    
        .def( 
            "reset"
            , (void ( ::vme::IO32::* )(  ) )( &::vme::IO32::reset ) )    
        .def( 
            "unpack"
            , (bool ( ::vme::IO32::* )( ::midas::Event const &,char const *,bool ) )( &::vme::IO32::unpack )
            , ( bp::arg("event"), bp::arg("bankName"), bp::arg("reportMissing")=(bool)(false) ) )    
        .def_readwrite( "busy_time", &vme::IO32::busy_time )    
        .def_readwrite( "end", &vme::IO32::end )    
        .def_readwrite( "header", &vme::IO32::header )    
        .def_readwrite( "latency", &vme::IO32::latency )    
        .def_readwrite( "read_time", &vme::IO32::read_time )    
        .def_readwrite( "start", &vme::IO32::start )    
        .def_readwrite( "trig_count", &vme::IO32::trig_count )    
        .def_readwrite( "trigger_latch", &vme::IO32::trigger_latch )    
        .def_readwrite( "tstamp", &vme::IO32::tstamp );

    { //::vme::V1190
        typedef bp::class_< V1190_wrapper > V1190_exposer_t;
        V1190_exposer_t V1190_exposer = V1190_exposer_t( "V1190", bp::init< >() );
        bp::scope V1190_scope( V1190_exposer );
        { //::vme::V1190::Channel
            typedef bp::class_< V1190_wrapper::Channel_wrapper > Channel_exposer_t;
            Channel_exposer_t Channel_exposer = Channel_exposer_t( "Channel" );
            bp::scope Channel_scope( Channel_exposer );
            pyplusplus::containers::static_sized::register_array_1< int, 5 >( "__array_1_int_5" );
            { //vme::V1190::Channel::leading_edge [variable], type=int32_t[5]
            
                typedef pyplusplus::containers::static_sized::array_1_t< int, 5> ( *array_wrapper_creator )( ::vme::V1190::Channel & );
                
                Channel_exposer.add_property( "leading_edge"
                    , bp::make_function( array_wrapper_creator(&V1190_wrapper::Channel_wrapper::pyplusplus_leading_edge_wrapper)
                                        , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
            }
            Channel_exposer.def_readwrite( "nleading", &vme::V1190::Channel::nleading );
            Channel_exposer.def_readwrite( "ntrailing", &vme::V1190::Channel::ntrailing );
            { //vme::V1190::Channel::trailing_edge [variable], type=int32_t[5]
            
                typedef pyplusplus::containers::static_sized::array_1_t< int, 5> ( *array_wrapper_creator )( ::vme::V1190::Channel & );
                
                Channel_exposer.add_property( "trailing_edge"
                    , bp::make_function( array_wrapper_creator(&V1190_wrapper::Channel_wrapper::pyplusplus_trailing_edge_wrapper)
                                        , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
            }
        }
        { //::vme::V1190::get_data
        
            typedef ::int16_t ( ::vme::V1190::*get_data_function_type )( ::int16_t ) const;
            
            V1190_exposer.def( 
                "get_data"
                , get_data_function_type( &::vme::V1190::get_data )
                , ( bp::arg("ch") ) );
        
        }
        { //::vme::V1190::reset
        
            typedef void ( ::vme::V1190::*reset_function_type )(  ) ;
            
            V1190_exposer.def( 
                "reset"
                , reset_function_type( &::vme::V1190::reset ) );
        
        }
        { //::vme::V1190::unpack
        
            typedef bool ( ::vme::V1190::*unpack_function_type )( ::midas::Event const &,char const *,bool ) ;
            
            V1190_exposer.def( 
                "unpack"
                , unpack_function_type( &::vme::V1190::unpack )
                , ( bp::arg("event"), bp::arg("bankName"), bp::arg("reportMissing")=(bool)(false) ) );
        
        }
        V1190_exposer.def_readonly( "EXTENDED_TRIGGER_TIME", vme::V1190::EXTENDED_TRIGGER_TIME );
        V1190_exposer.def_readonly( "GLOBAL_HEADER", vme::V1190::GLOBAL_HEADER );
        V1190_exposer.def_readonly( "GLOBAL_TRAILER", vme::V1190::GLOBAL_TRAILER );
        V1190_exposer.def_readonly( "MAX_CHANNELS", vme::V1190::MAX_CHANNELS );
        V1190_exposer.def_readonly( "MAX_HITS", vme::V1190::MAX_HITS );
        V1190_exposer.def_readonly( "TDC_ERROR", vme::V1190::TDC_ERROR );
        V1190_exposer.def_readonly( "TDC_HEADER", vme::V1190::TDC_HEADER );
        V1190_exposer.def_readonly( "TDC_MEASUREMENT", vme::V1190::TDC_MEASUREMENT );
        V1190_exposer.def_readonly( "TDC_TRAILER", vme::V1190::TDC_TRAILER );
        V1190_exposer.def_readwrite( "bunch_id", &vme::V1190::bunch_id );
        pyplusplus::containers::static_sized::register_array_1< ::vme::V1190::Channel, 64, bp::return_internal_reference< > >( "__array_1__scope_vme_scope_V1190_scope_Channel_64" );
        { //vme::V1190::channel [variable], type=vme::V1190::Channel[64]
        
            typedef pyplusplus::containers::static_sized::array_1_t< ::vme::V1190::Channel, 64> ( *array_wrapper_creator )( ::vme::V1190 & );
            
            V1190_exposer.add_property( "channel"
                , bp::make_function( array_wrapper_creator(&V1190_wrapper::pyplusplus_channel_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        V1190_exposer.def_readwrite( "count", &vme::V1190::count );
        V1190_exposer.def_readwrite( "event_id", &vme::V1190::event_id );
        V1190_exposer.def_readwrite( "extended_trigger", &vme::V1190::extended_trigger );
        V1190_exposer.def_readwrite( "n_ch", &vme::V1190::n_ch );
        V1190_exposer.def_readwrite( "status", &vme::V1190::status );
        V1190_exposer.def_readwrite( "trailer_word_count", &vme::V1190::trailer_word_count );
        V1190_exposer.def_readwrite( "type", &vme::V1190::type );
        V1190_exposer.def_readwrite( "word_count", &vme::V1190::word_count );
    }

    { //::vme::V792
        typedef bp::class_< V792_wrapper > V792_exposer_t;
        V792_exposer_t V792_exposer = V792_exposer_t( "V792", bp::init< >() );
        bp::scope V792_scope( V792_exposer );
        { //::vme::V792::get_data
        
            typedef ::int16_t ( ::vme::V792::*get_data_function_type )( ::int16_t ) const;
            
            V792_exposer.def( 
                "get_data"
                , get_data_function_type( &::vme::V792::get_data )
                , ( bp::arg("ch") ) );
        
        }
        { //::vme::V792::reset
        
            typedef void ( ::vme::V792::*reset_function_type )(  ) ;
            
            V792_exposer.def( 
                "reset"
                , reset_function_type( &::vme::V792::reset ) );
        
        }
        { //::vme::V792::unpack
        
            typedef bool ( ::vme::V792::*unpack_function_type )( ::midas::Event const &,char const *,bool ) ;
            
            V792_exposer.def( 
                "unpack"
                , unpack_function_type( &::vme::V792::unpack )
                , ( bp::arg("event"), bp::arg("bankName"), bp::arg("reportMissing")=(bool)(false) ) );
        
        }
        V792_exposer.def_readonly( "DATA_BITS", vme::V792::DATA_BITS );
        V792_exposer.def_readonly( "FOOTER_BITS", vme::V792::FOOTER_BITS );
        V792_exposer.def_readonly( "HEADER_BITS", vme::V792::HEADER_BITS );
        V792_exposer.def_readonly( "INVALID_BITS", vme::V792::INVALID_BITS );
        V792_exposer.def_readonly( "MAX_CHANNELS", vme::V792::MAX_CHANNELS );
        V792_exposer.def_readwrite( "count", &vme::V792::count );
        pyplusplus::containers::static_sized::register_array_1< short int, 32 >( "__array_1_short_int_32" );
        { //vme::V792::data [variable], type=int16_t[32]
        
            typedef pyplusplus::containers::static_sized::array_1_t< short int, 32> ( *array_wrapper_creator )( ::vme::V792 & );
            
            V792_exposer.add_property( "data"
                , bp::make_function( array_wrapper_creator(&V792_wrapper::pyplusplus_data_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        V792_exposer.def_readwrite( "n_ch", &vme::V792::n_ch );
        V792_exposer.def_readwrite( "overflow", &vme::V792::overflow );
        V792_exposer.def_readwrite( "underflow", &vme::V792::underflow );
    }
}
