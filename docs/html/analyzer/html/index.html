<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DRAGON Analyzer: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DRAGON Analyzer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">DRAGON Analyzer Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro">Introduction</a></li>
<li class="level1"><a href="#daq">DRAGON Data Acquisition (DAQ)</a><ul><li class="level2"><a href="#hardware">DRAGON Hardware</a></li>
<li class="level2"><a href="#trigger">Trigger</a></li>
<li class="level2"><a href="#data">Data Format</a><ul><li class="level3"><a href="#midas">MIDAS</a></li>
<li class="level3"><a href="#midasbanks">MIDAS Banks</a></li>
<li class="level3"><a href="#caenadc">CAEN V792/V785 ADC</a></li>
<li class="level3"><a href="#caentdc">CAEN V1190 TDC</a></li>
<li class="level3"><a href="#vmeio32">IO32 FPGA/Control Board</a></li>
<li class="level3"><a href="#coincmatch">Coincidence Matching</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#installation">Installation</a><ul><li class="level2"><a href="#dependencies">Dependencies</a></li>
<li class="level2"><a href="#download">Download and Compile</a></li>
<li class="level2"><a href="#pyext">Python Extension</a></li>
</ul>
</li>
<li class="level1"><a href="#using">For Users</a><ul><li class="level2"><a href="#rootana">Rootana Online Analyzer</a></li>
</ul>
</li>
<li class="level1"><a href="#developers">For Developers</a><ul><li class="level2"><a href="#design">Design</a></li>
<li class="level2"><a href="#conventions">Coding Conventions</a></li>
<li class="level2"><a href="#doc">Documentation</a></li>
</ul>
</li>
<li class="level1"><a href="#footnotes">Footnotes</a></li>
</ul>
</div>
<div class="textblock"><dl class="section author"><dt>Authors</dt><dd>G. Christian<br />
 C. Stanford<br />
 K. Olchanski</dd></dl>
<h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p class="">This software package is developed for the analysis of data collected in <a href="http://dragon.triumf.ca">DRAGON</a> experiments at <a href="http://www.triumf.ca">TRIUMF</a>. The software is intended for experiments run with the "new" (c. 2013) DRAGON data acquisition system (VME hardware + timestamp coincidence matching).</p>
<p class="">At its core, the package is simply a collection of routines to extract ("unpack") the <a href="https://midas.triumf.ca">MIDAS</a> data generated during an experiment into a format that is more suitable for human consumption, as well as to perform some of the more basic and commonly needed analysis tasks. From here, users can further process the data using their own codes, or they can interface with a visualization library to view the data in histograms, either online or offline. The core of the package is written in "plain" C++, that is without any dependence on libraries other than the standard library.</p>
<p class="">In addition to the "core", this package also includes code to interface with the <a href="https://bitbucket.org/tmidas/rootana">rootana</a> data analysis package distributed as part of <a href="https://midas.triumf.ca">MIDAS</a> and the <a href="http://trshare.triumf.ca/~gchristian/rootbeer/doc/html/index.html">rootbeer</a> program for data visualization. Each of these packages is designed for "user friendly" viewing of data in histograms, either from saved files or real-time online data. Both require that a relatively recent version of <a href="https://root.cern.ch">ROOT</a> be installed on your system, and, additionally, <a href="https://midas.triumf.ca/MidasWiki/index.php/Installation">MIDAS must be installed</a> in order to look at online data (offline data viewing should be possible without a MIDAS installation, however). In addition, it is required that ROOT be build with the <code>minuit2</code> and <code>xml</code> options set to <code>ON</code>.</p>
<p class="">There is also an optional extension to create python wrappers for the DRAGON classes, allowing data to be analyzed in python independent of ROOT/PyRoot. This package is somewhat in the experimental stage at the moment and requires installation of <a href="http://www.boost.org/doc/libs/1_66_0/libs/python/doc/html/index.html"><code>Boost.Python</code></a> to compile the libraries.</p>
<p class="">If you have a specific question about package, you may want to check out the <a href="faq.html">FAQ</a> to see if it is addresed there.</p>
<h1><a class="anchor" id="daq"></a>
DRAGON Data Acquisition (DAQ)</h1>
<p class="">Before launching into a description of the analysis software, I will first give an overview of how the DRAGON data-acquisition is structured. This is intended to serve as documentation of the bit-packed structure of DRAGON event data, as well as the trigger logic and related topics.</p>
<h2><a class="anchor" id="hardware"></a>
DRAGON Hardware</h2>
<p class="">The DRAGON data acquisiton consists of two separate VME crates, one for the "head" or gamma-ray detectors, and the other for the "tail" or heavy-ion detectors. Each crate is triggered and read out separately, and tagged with a timestamp from a "master" clock that is part of the head electronics. In the analysis, the timestamps from each side are compared to look for matches (events whose timestamps differ by less than a certain time window). Matching events are deemed coincidences and analyzed as such, while events without a match are handled as singles.</p>
<p class="">In the standard configuration, the head and tail DAQ systems read data from the following VME modules:</p>
<ul>
<li>Head<ul>
<li>One IO32 FPGA/control board.</li>
<li>One CAEN V792 32-channel, charge-sensing ADC (or 'QDC').</li>
<li>One CAEN V1190B 64-channel, multi-hit TDC.</li>
</ul>
</li>
<li>Tail<ul>
<li>One IO32 FPGA/control board.</li>
<li>Two CAEN V785 32-channel, peak-sensing ADCs.</li>
<li>One CAEN V1190B 64-channel multi-hit TDC.</li>
</ul>
</li>
</ul>
<p class="">Additionally, both sides contain a VME processor or "frontend" which runs the MIDAS data-acquisition code and is connected via the network to a "backend" computer (<code>smaug</code>) which performs analysis and logging (writing to disk) functions.</p>
<h2><a class="anchor" id="trigger"></a>
Trigger</h2>
<p class="">The following figure shows a simplified diagram of the trigger logic (identical for head and tail DAQs):</p>
<div class="image">
<img src="trigger.png" alt="trigger.png"/>
</div>
<p class="">The logic starts with up to eight digital (descriminator) NIM signals being sent into a NIM -&gt; ECL level converter. The output is then sent via a ribbon cable to the "ECL inputs" of the IO32. The eight signals are then processed in the IO32's internal FPGA. First they are sent through a bitmask, where individual channels can be ignored by writing the appropriate bits to an FPGA register. This allows individual channels to be removed from or added to the trigger logic without physically unplugging/plugging in any cables. From here, the unmasked channels are ORed to create a single "master" trigger signal, which is output via a LEMO cable from the IO32. This signal is then routed back into the IO32 via one of its NIM inputs: it is sent into either NIM input 2 or 3. These two signals (NIM in 2 and 3) are ORed internally and sent through an FPGA logic sequence to generate three output signals:</p>
<ol type="1">
<li>"Trigger"</li>
<li>"Gate"</li>
<li>"TDC Trigger"</li>
</ol>
<p class="">The "trigger" signal is routed back into the IO32, where it sets off the internal logic to identify that an event has occured. This also prompts the generation of a "busy" signal which can be used to block the generation of additional triggers while the current event is processing. The arrival time of the "trigger" signal is also stored in an internal register, and serves as the "timestamp" to identify coincidence vs. singles events (more on this later). The "gate" signal is a NIM logic pulse with a programmable width, and it is routed into the ADC(s) to serve as their common integration or peak-finding window. The "TDC trigger" signal is also a NIM logic pulse, which can be delayed by a programmable amount of time. It is routed into the TDC, where it serves as the "trigger" (this is similar to a "stop" signal - the TDC will time pulses arriving within a programmable time window proceeding the arrival of the trigger).</p>
<h2><a class="anchor" id="data"></a>
Data Format</h2>
<h3><a class="anchor" id="midas"></a>
MIDAS</h3>
<p class="">This section gives a brief overview of the MIDAS data format and, more importantly, how it is decoded for DRAGON data analysis. This is in no way exhaustive, and for more information, the reader should consult the <a href="https://midas.triumf.ca/MidasWiki/index.php/Midas_documentation">MIDAS documentation page</a>. Readers who are already familiar with the MIDAS data format may wish to skip to the <a href="#midasbanks">MIDAS Banks section</a> where the specifics of DRAGON data are discussed. For more information on MIDAS event structure, consult <a href="https://midas.triumf.ca/MidasWiki/index.php/Event_Structure">https://midas.triumf.ca/MidasWiki/index.php/Event_Structure</a> .</p>
<p class="">MIDAS files are first organized into "events". For DRAGON, each event corresponds to a single trigger of the VME system(s). The analysis code handles everything on an event-by-event basis: each event block is fully analyzed before moving onto the next one. This means that the analyzer code needs some way of obtaining the individual blocks of data that correspond to a single event. This is mostly handled using "library" functions provided as part of the MIDAS package - in other words, we let the MIDAS developers handle the details of grabbing each event's data and simply incorporate the functions they have written into our own codes.</p>
<p class="">Events are obtained in different ways depending on whether we are analyzing "online" data (data that are being generated in real time and sent to the backend analyzer via the network) or "offline" data (data stored in a MIDAS [.mid] file on disk). For online data, we use a set of routines that periodically poll the frontend computer, asking if any new events have been generated. When the frontend responds with a new event, the corresponding data are copied into a section of RAM allocated to the analysis program (often called the "event buffer"). At this point, the data now are part of the analysis program, and can be further processed using a suite of specifically designed analysis routines. For offline data, we again make use of stock MIDAS routines to extract event data into a local buffer for analysis. However, here we are not asking for events in real time; instead, we are extracting them from a file consisting of a series of events strung together. To do this, we use a set of functions that understand the detailed structure of a MIDAS file and can figure out the exact blocks of data corresponding to single events.</p>
<p class="">Once we have obtained an event and stored it in a local analysis buffer, the next step is to identify the individual packets containing data from the various VME modules. Actually, there is one important step coming before this: the individual events are placed into a local buffer (a "buffer of buffers") and, after a certain amount of time, pre-analyzed to check for coincidence matches. For more on this, see the <a href="#coincmatch">coincidence matching section</a>. As mentioned above, once we have a single, defined event, we need to break it down into packets or "banks" in order to analyze the data from individual VME modules. Each bank contains a header with some unique identifying information about the bank, and from there the actual bank data follow. In the header, each bank is identified by a unique 4-character string. All we have to do, then, is use library routines which search for banks keyed by their ID strings. If the corresponding bank is present within the current event, the routine will return a pointer to the memory address of the beginning of the bank, along with some other relevant information, such as the total amount of data in the event and the type of data being stored.</p>
<p class="">The actual data are simply a series of bits organized into constant-sized chunks. Each "chunk" is a unique datum (a number), corresponding to one of the <a href="http://en.wikipedia.org/wiki/C_data_types">C/C++ data types</a>. Depending on how the data were written, each number could be the most basic source of information, summarizing everything there is to know about a given parameter, or it could be further sub-divided into smaller pieces of information given by the sequence of bits that make up the number within the computer. If the data are "bitpacked," then typically the code will make use of bit shifting and bit masking operators to extrack the information from the desired bits (more on this in the example below).</p>
<p class="">The only way to know how to properly handle the data is to know ahead of time how the data were written and how their relevant information is written into the various chunks of data making up a MIDAS bank. A typical analysis code will loop over all of the data in the bank, and then decide how to handle it based either on foreknowledge of the exact bank structure or on information contained in specific bits within each word.</p>
<p class="">As an example, take a slightly modified version of the code to unpack V792 ADC data:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classvme_1_1_v792.html#a3fdab8d6c03c5f892625e15c8fc1b917">vme::V792::unpack</a>(<span class="keyword">const</span> <a class="code" href="classmidas_1_1_event.html">midas::Event</a>&amp; event, <span class="keyword">const</span> <span class="keywordtype">char</span>* bankName, <span class="keywordtype">bool</span> reportMissing)</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> ret = <span class="keyword">true</span>; <span class="comment">// return value</span></div><div class="line"></div><div class="line">  <span class="comment">// Search for a MIDAS bank with the correct name (the value of the variable &#39;bankName&#39;)</span></div><div class="line">  <span class="keywordtype">int</span> bank_len;</div><div class="line">  uint32_t* pbank32 = <span class="keyword">event</span>.GetBankPointer&lt;uint32_t&gt;(bankName, &amp;bank_len, reportMissing, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  <span class="comment">// pbank32 is now set to the address of the bank with name &#39;bankName&#39;. We know ahead of time that</span></div><div class="line">  <span class="comment">// the bank contains a set of longwords (uint32_t), and bank_len is now set to the number of longwords</span></div><div class="line">  <span class="comment">// stored in the bank.</span></div><div class="line"></div><div class="line">  <span class="comment">// Loop over all data words in the bank</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; bank_len; ++i) {</div><div class="line">    <span class="comment">// Read bits 24, 25, 26 to figure out the type of data in this particular longword</span></div><div class="line">    uint32_t type = (*pbuffer &gt;&gt; 24) &amp; 0x7;</div><div class="line">    <span class="comment">// Now decide what to do based on the value of &#39;type&#39;</span></div><div class="line">    <span class="keywordflow">switch</span> (type) {</div><div class="line">        </div><div class="line">        <span class="keywordflow">case</span> 0x0: <span class="comment">// Data bits</span></div><div class="line">        <span class="comment">// Figure out the measurement value, copy into vme::V792 class data.</span></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">        </div><div class="line">        <span class="keywordflow">case</span> 0x2: <span class="comment">// Header bits</span></div><div class="line">        <span class="comment">// Read relevant header information and proceed.</span></div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">// ... etc for other data types ... //</span></div><div class="line"></div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">    } <span class="comment">// Note: Somewhere along the line, set &#39;ret&#39; to &#39;false&#39; if there was an error.</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> ret;</div><div class="line">}</div></div><!-- fragment --><p class="">If you are unfamiliar with C/C++ bit shifting and masking, the line <code>(*pbuffer &gt;&gt; 24) &amp; 0x7</code> might be confusing to you. The basic idea is that you are taking the value of the 32 bits stored at the address pointed to by <code>pbuffer</code> (<code>*pbuffer</code> extracts the value) and first shifting it by 24 bits, then masking it with the value of <code>0x7</code>, that is, extracting only the first three bits, which now correspond to bits 24, 25, 26 since <code>*pbuffer</code> has already been shifted by 24 bits to the right. Here is a figure to help visualize the process:</p>
<div class="image">
<img src="bits.png" alt="bits.png"/>
</div>
<h3><a class="anchor" id="midasbanks"></a>
MIDAS Banks</h3>
<p class="">The frontend codes generate four different types of events, with the following characteristics:</p>
<ol type="1">
<li>"Head Event"<ul>
<li>Event Id: 1 (or DRAGON_HEAD_EVENT in <a class="el" href="definitions_8h.html" title="Defines constants used by multiple MIDAS clients.">definitions.h</a>)</li>
<li>MIDAS Equipment: <code>HeadVME</code></li>
<li>Trigger condition: OR of all BGO channels</li>
<li>Banks:<ol type="a">
<li>"VTRH": IO32 data</li>
<li>"ADC0": V792 QDC data</li>
<li>"TDC0": V1190 TDC data</li>
<li>"TSCH": Timestamp counter data from the IO32 <br />
</li>
</ol>
</li>
</ul>
</li>
<li>"Head Scaler Event"<ul>
<li>Event Id: 2 (or DRAGON_HEAD_SCALER in <a class="el" href="definitions_8h.html" title="Defines constants used by multiple MIDAS clients.">definitions.h</a>)</li>
<li>MIDAS Equipment: <code>HeadScaler</code></li>
<li>Trigger condition: polled once per second</li>
<li>Banks:<ol type="a">
<li>"SCHD": Scaler counts (for the current read period, ~1 second)</li>
<li>"SCHS": Scaler sum (since the beginning of the run)</li>
<li>"SCHR": Scaler rates (counts/second for the current read period) <br />
</li>
</ol>
</li>
</ul>
</li>
<li>"Tail Event"<ul>
<li>Event Id: 3 (or DRAGON_TAIL_EVENT in <a class="el" href="definitions_8h.html" title="Defines constants used by multiple MIDAS clients.">definitions.h</a>)</li>
<li>MIDAS Equipment: <code>TailVME</code></li>
<li>Trigger condition: OR of all heavy ion detectors</li>
<li>Banks:<ol type="a">
<li>"VTRT": IO32 data</li>
<li>"TLQ0": V785 ADC data (unit 0).</li>
<li>"TLQ1": V785 ADC data (unit 1).</li>
<li>"TLT0": V1190 TDC data</li>
<li>"TSCT": Timestamp counter data from the IO32 <br />
</li>
</ol>
</li>
</ul>
</li>
<li>"Tail Scaler Event"<ul>
<li>Event Id: 4 (or DRAGON_TAIL_SCALER in <a class="el" href="definitions_8h.html" title="Defines constants used by multiple MIDAS clients.">definitions.h</a>)</li>
<li>MIDAS Equipment: <code>TailScaler</code></li>
<li>Trigger condition: polled once per second</li>
<li>Banks:<ol type="a">
<li>"SCTD": Scaler counts (for the current read period, ~1 second)</li>
<li>"SCTS": Scaler sum (since the beginning of the run)</li>
<li>"SCTR": Scaler rates (counts/second for the current read period)</li>
</ol>
</li>
</ul>
</li>
</ol>
<p class=""><br />
</p>
<h3><a class="anchor" id="caenadc"></a>
CAEN V792/V785 ADC</h3>
<p class="">The data format of CAEN V792 charge-sensing and CAEN V785 peak-sensing ADCs is exactly the same; in fact, identical code is used to write and to analyze the data stored by each module. A single event from a V792/V785 is organized into 32-bit "longwords". A generic event looks something like this:</p>
<div class="image">
<img src="v792event.png" alt="v792event.png"/>
</div>
<p class="">starting with a header longword, followed by a series of data longwords, and finishing with a footer longword. Each of these longwords contains multiple pieces of information given by individual series of bits within the longword. The bit structure and purpose of each type of longword is as follows:</p>
<p class=""><br />
<b>Header</b></p>
<p class="">The header longwords give specific information about the module and the current event. The data are sub-divided into bits as follows:</p>
<div class="image">
<img src="v792header.png" alt="v792header.png"/>
</div>
<ul>
<li>Bits 0 - 7: Unused</li>
<li>Bits 8 - 13: Identify the total number of data longwords in the event.</li>
<li>Bits 14 - 15: Unused</li>
<li>Bits 16 - 23: Identify the "crate number" of the present module (ignored for DRAGON experiments).</li>
<li>Bits 24 - 26: Uniquely identify the longword as a header, that is, all headers have the sequence 0 1 0 for these bits.</li>
<li>Bits 27 - 31: Identify the "geo address" of the present module (ignored for DRAGON experiments).</li>
</ul>
<p class=""><br />
<b>Data</b></p>
<p class="">The data longwords tell the actual measurement value of a specific channel, that is, they tell what the integrated charge or maximum height of the signal going into a single channel is. Data longwords are arranged as follows:<br />
<br />
 </p><div class="image">
<img src="v792data.png" alt="v792data.png"/>
</div>
<ul>
<li>Bits 0 - 11: Encode the measurement value for the channel in question. Note that since this is an 12-bit number, the measurement values can be within the range [0, 4095] (or [0x0, 0xfff]).</li>
<li>Bit 12: Single bit telling if the channel in question was in an overflow condition (signal larger than the maximum). '1' corresponds to a channel that is in overflow, '0' to one not in overflow.</li>
<li>Bit 13: Same as bit 12, except it tells if the channel is in an _under_flow condition (below a certain threshold).</li>
<li>Bits 14 - 15: Unused.</li>
<li>Bits 16 - 20: Encode the number of the channel in question, i.e. if these bits evaluate to 5, we are reading input channel five, and so on.</li>
<li>Bits 21 - 23: Unused.</li>
<li>Bits 24 - 26: Uniquely identify the longword as a "data" word: all data words have the sequence 0 0 0 for these bits.</li>
<li>Bits 27 - 31: Copy of the "geo" address from the header.</li>
</ul>
<p class=""><br />
<b>Footer</b></p>
<p class="">The main purpose of footer lngwords is to provide a counter for the total number of events received during a run.</p>
<div class="image">
<img src="v792footer.png" alt="v792footer.png"/>
</div>
<ul>
<li>Bits 0 - 23: Event counter, increments automatically every time a new event is read.</li>
<li>Bits 24 - 26: Ideitify this longword as a footer; all footers have the sequence 0 0 1 for these bits.</li>
<li>Bits 27 - 31: Copy of the "geo" address.</li>
</ul>
<p class="">Finally, in addition to the types mentioned above, a longword can also be an <em>invalid</em> word, which is IDed by <code>0 0 1</code> for bits 24 - 26. An invalid word typically signifies some sort of error condition within the ADC.</p>
<h3><a class="anchor" id="caentdc"></a>
CAEN V1190 TDC</h3>
<p class="">The structure of a V1190 TDC event is somewhat similar to that of a V792/V785 ADC: each event consists of a series of longwords, with the general structure of [Header], [Data], [Data], ..., [Data], [Footer]. In addition, there is also a "global" header attached to each event. Unlike the V792, we do not necessairily have only a single data longword per channel; this is because the V1190 is a "multi-hit" device, that is, it is capable of registering multiple timing measurements if more than one pulse goes into a given channel during recording of an event. Additionally, the user may set the TDC to record the time of both the front and the back of a given pulse, and each of these will count as a different "hit" on the channel.</p>
<p class="">Below are the bit packed structures of the various types of longwords that can be read from a V1190 TDC. Note that the V1190 is a rather complex device and can run in varying operating modes. The documentation below is only relevant in the "trigger matching" mode, which is how DRAGON operates. For information about other running options, consult the manual (available online from the CAEN website).</p>
<p class=""><br />
<b>Global Header</b></p>
<p class="">The global header contains an event counter and some other common information about the module.</p>
<div class="image">
<img src="v1190global_header.png" alt="v1190global_header.png"/>
</div>
<ul>
<li>Bits 0 - 4: "Geo" address (unused for DRAGON).</li>
<li>Bits 5 - 26: Event counter.</li>
<li>Bits 27 - 31: Identify the longword in question as a global header with the unique sequence of 0 0 0 1 0 for these bits.</li>
</ul>
<p class=""><br />
<b>TDC Header</b></p>
<p class="">The (optional) TDC header contains information about a apecific TDC trigger.</p>
<div class="image">
<img src="v1190header.png" alt="v1190header.png"/>
</div>
<ul>
<li>Bits 0 - 11: Encode the bunch id of the trigger.</li>
<li>Bits 12 - 23: Encode the event ID.</li>
<li>Bits 24 - 25: TDC code (unused for DRAGON).</li>
<li>Bit 26: Unused.</li>
<li>Bits 27 - 31: Identify the longword in question as a TDC header by having the sequence 1 0 0 0 0.</li>
</ul>
<p class=""><br />
<b>Measurement</b></p>
<p class="">A measurement longword contains the information of a single timing measurement made by the device.</p>
<div class="image">
<img src="v1190data.png" alt="v1190data.png"/>
</div>
<ul>
<li>Bits 0 - 19: Encode the measurement value. As an 19-bit number, this allows measurements in the range <code>[0, 524287]</code> (or <code>[0x0, 0x7ffff]</code>).</li>
<li>Bits 19 - 25: Encode the channel number of the measurement in question.</li>
<li>Bit 26: Tells whether the measurement in question is a trailing-edge measurement ('1') or a leading-edge measurement ('0').</li>
<li>Bits 27 - 31: Identify the longword in question as a measurement by having the sequence 0 0 0 0 0.</li>
</ul>
<p class=""><br />
<b>TDC Trailer</b></p>
<p class="">The (optional) TDC Trailer provides some additional information about a TDC trigger.</p>
<div class="image">
<img src="v1190trailer.png" alt="v1190trailer.png"/>
</div>
<ul>
<li>Bits 0 - 11: Count of the number of words read from the trigger.</li>
<li>Bits 12 - 23: ID code of the trigger.</li>
<li>Bits 24 - 25: TDC code (unused for DRAGON).</li>
<li>Bit 26: Unused.</li>
<li>Bits 27 - 31: Identify the longword in question as a TDC trailer by having the sequence 1 1 0 0 0.</li>
</ul>
<p class=""><br />
<b>Global Trailer</b></p>
<p class="">The global trailer contains some information that is common to all events.</p>
<div class="image">
<img src="v1190global_trailer.png" alt="v1190global_trailer.png"/>
</div>
<ul>
<li>Bits 0 - 4: "Geo" address of the module (unused in DRAGON).</li>
<li>Bits 5 - 20: Number of words currently read.</li>
<li>Bits 21 - 23: Unused.</li>
<li>Bits 24 - 26: Encodes the status of the current event. If all three bits are zero, then we are in a "no error" condition. For the various "error" conditions and the bits that signal them, consult the figure.</li>
<li>Bits 27 - 31: Identify the current longword as a global trailer via the sequence 0 0 0 0 1.</li>
</ul>
<p class=""><br />
<b>Error</b></p>
<p class="">This type of longword is only present if the TDC is in an error condition.</p>
<div class="image">
<img src="v1190error.png" alt="v1190error.png"/>
</div>
<ul>
<li>Bits 0 - 14: Encode the error status. Each bit that is set to '1' signifies a unique error condition:<ul>
<li>[0]: Hit lost in group 0 from read-out FIFO overflow.</li>
<li>[1]: Hit lost in group 0 from L1 buffer overflow</li>
<li>[2]: Hit error have been detected in group 0.</li>
<li>[3]: Hit lost in group 1 from read-out FIFO overflow.</li>
<li>[4]: Hit lost in group 1 from L1 buffer overflow</li>
<li>[5]: Hit error have been detected in group 1.</li>
<li>[6]: Hit data lost in group 2 from read-out FIFO overflow.</li>
<li>[7]: Hit lost in group 2 from L1 buffer overflow</li>
<li>[8]: Hit error have been detected in group 2.</li>
<li>[9]: Hit lost in group 3 from read-out FIFO overflow.</li>
<li>[10]: Hit lost in group 3 from L1 buffer overflow</li>
<li>[11]: Hit error have been detected in group 3.</li>
<li>[12]: Hits rejected because of programmed event size limit</li>
<li>[13]: Event lost (trigger FIFO overflow).</li>
<li>[14]: Internal fatal chip error has been detected.</li>
</ul>
</li>
<li>Bits 15 - 23: Unused.</li>
<li>Bits 24 - 25: TDC code (unused for DRAGON).</li>
<li>Bit 26: Unused.</li>
<li>Bits 27 - 31: Identify the current longword as an error word via the sequence 0 0 1 0 0.</li>
</ul>
<h3><a class="anchor" id="vmeio32"></a>
IO32 FPGA/Control Board</h3>
<p class="">Data from the IO32 FPGA/control board are written into two separate MIDAS banks. The first bank contains information about the trigger conditions generating the present event. It consists of nine 32-bit longwords, and each longword, save for one, corresponds to a single piece of information about the trigger (i.e. no sub dividing into bits as with the CAEN modules). The nine longwords read from the trigger bank are as follows:</p>
<ol type="1">
<li>Header and version number of the IO32.</li>
<li>Number of triggers (starting with zero) since the beginning of the run.</li>
<li>Timestamp marking the arrival of the trigger signal.</li>
<li>Timestamp marking when the data readout began.</li>
<li>Timestamp marking when the data readout ended.</li>
<li>Trigger latency: the difference in timestamps between the trigger and the start of the readout.</li>
<li>Readout elapsed time: the difference in timestamps between the end of the readout and the start of the readout.</li>
<li>Busy elapsed time: the difference in timestamps between the end of the readout and the trigger.</li>
<li>Trigger latch value: This is the only bitpacked value in the IO32 trigger bank. The first eight bits in the longword signify which of the eight input channels generated the trigger. Whichever bit is true is the channel making the trigger. For example, a value of 0x4 [ bits: 00000000000000000000000000000100 ] means that input 3 generated the trigger.</li>
</ol>
<p class="">The other bank consisting of IO32 data is the timestamp counter (TSC) bank. This bank contains timestamp information for both the event trigger and other programmable channels (such as the "cross" trigger, or the trigger of the other DAQ, if it is present). It is here that we look to identify which events are singles events and which are coincidences. The actual TSC data are stored in a FIFO (first in, first out) with a maximum depth set by firmware limitations. Any pulses arriving beyond the limits of the FIFO are ignored.</p>
<p class="">The TSC banks are arranged as follows (all 32-bit unsigned integers).</p>
<ol type="1">
<li>Version number (firmware revision tag).<ul>
<li>Currently ignored other than a check that the version numbner is a known one.<br />
<br />
</li>
</ul>
</li>
<li>Bank timestamp (time at which the TSC bank was composed).<ul>
<li>Currently ignored.<br />
<br />
</li>
</ul>
</li>
<li>TSC routing bits (sets TSC signal routing for the frontend)<ul>
<li>Ignored for analysis.<br />
<br />
</li>
</ul>
</li>
<li>TSC control<ul>
<li>Contains the following bitpacked information:<ol type="a">
<li>Bits 13..0 - Number of TSC words in the FIFO</li>
<li>Bit 14 - FIFO overflow marker</li>
<li>Bits 21..15 - Upper 8 bits common to each TSC in the FIFO.<br />
<br />
</li>
</ol>
</li>
</ul>
</li>
<li>Upper bits rollover<ul>
<li>Firmware limits each TSC measurement to 38 bits, which rolls over in ~3.8 hours. Runs could occasionally go longer than this, so we manually count the number of rollovers in the upper 8 bits in the frontend code and write it here.<br />
<br />
</li>
</ul>
</li>
<li>FIFO (depth given by TSC control as noted above)<ul>
<li>Each entry is bitpacked as follows:<ol type="a">
<li>Bits 0..29 - Lower 30 bits of the timestamp entry (combine with upper 8 bits plus upper bits rollover marker)</li>
<li>Bits 30..31 - Channel marker (0,1,2,3) for this TSC measurement<br />
<br />
</li>
</ol>
</li>
</ul>
</li>
<li>Overflow marker: additional word <code>== 0xFFFFFFFF</code> is written if the TSC is in an overflow condition.<ul>
<li>Currently ignored because TSC control gives the same information.</li>
</ul>
</li>
</ol>
<h3><a class="anchor" id="coincmatch"></a>
Coincidence Matching</h3>
<p class="">An important topic related to the TSC bank is the method used to identify singles and coincidence events. As analysis of real-time, online data is quite important for DRAGON experiments, we need a method that is able to handle potential coincident head and tail events arriving at the backend at relatively different times. Since, as mentioned, MIDAS buffers events in the frontend before transferring to the backend via the network, events from each side are received in blocks. Potantially, coincident events could be quite far separated in terms of "event number" arriving at the backend.</p>
<p class="">The method used to match coincidence and singles events is to buffer every incoming event in a queue, sorted by their trigger time values. In practice, this is done using a <a href="http://www.cplusplus.com/reference/set/multiset/">C++ standard library multiset</a>, as this container was shown to be the most efficient way in which to order events by their trigger time value. Whenever a new event is placed in the queue, the code checks its current "length" in time, that is, it checks the time difference between the beginning of the queue (the earliest event) and the end of the queue (the latest event). If this time difference is greater than a certain value (user programmable), then the code searches for timestamp matches between the earliest event and all other events in the queue. Note that a "match" does not necessairily mean that the trigger times are exactly the same, as this would imply that the heavy ion and &gamma;-ray  were detected at exactly the same time, which is impossible for a real coincidence since the heavy ion must travel for a finite amount of time (~3 &mu;s). Thus, we define a "match" as two triggers whose time difference is within a programmable time window. Typically, this window is made significantly larger than the time difference of a true coincidence (~10 &mu;s), and further refinements can be made later by applying gates to the data.</p>
<div class="image">
<img src="tsmatch.png" alt="tsmatch.png"/>
</div>
<p class="">If a match is found, then the two events are analyzed as coincidences, and the earliest event is removed from the queue. If no match is found, the earliest event is analyzed as a singles event and then removed from the queue. As long as the maximum time difference is set large enough to cover any "spread" in the arrival times, this algorithm should guarantee that every coincidence is flagged as such.</p>
<h1><a class="anchor" id="installation"></a>
Installation</h1>
<p class="">This section gives an overwiew of how to obtain and install the latest version of the DRAGON data analysis package.</p>
<dl class="section note"><dt>Note</dt><dd>These instructions assume that you will install the dragon analyzer package in <code>~/packages/dragon</code>. If not, it will be necessary to alter the paths given below accordingly.</dd></dl>
<h2><a class="anchor" id="dependencies"></a>
Dependencies</h2>
<p class="">For the "core" functionality, all that you will need is a working C++ compiler; there is no dependence on any third-party libraries. However, you will likely want to make use of the analysis package in ROOT, in which case you will need a fairly recent installation of ROOT on your system. For instructions on installing ROOT, go <a href="http://root.cern.ch/drupal/content/downloading-root">here</a>. It is suggested that you install a relatively recent version of ROOT (say, &ge; 5.30) to ensure combatibilty between the ROOT release and the package code. You will also need to be sure that the <code>$ROOTSYS</code> environment variable is set and that <code>$ROOTSYS/bin</code> is in your search path. This is typically accomplished by sourcing the <code>thisroot.sh</code> or <code>thisroot.csh</code> script in <code>$ROOTSYS/bin</code> from your startup script (e.g. - <code>~/.bashrc</code>).</p>
<dl class="section attention"><dt>Attention</dt><dd><b>Ubuntu users:</b> compiling the DRAGON analyzer package evidently requires <code>clang</code> (<code>sudo apt-get install clang clang++</code>).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The DRAGON analyzer package is now compatible with ROOT6, but ROOT6 functionality should be considered beta until it has been tested more rigorously. Please report bugs to <a href="#" onclick="location.href='mai'+'lto:'+'dco'+'nn'+'oll'+'y@'+'tri'+'um'+'f.c'+'a'; return false;">dconnolly@triumf.ca</a> or <a href="https://github.com/DRAGON-Collaboration/analyzer/issues">file an issue here</a>.</dd></dl>
<p>The optional rootbeer or rootana extensions each require ROOT to be installed (and, of course, the rootana and/or rootbeer packages themselves). To look at <em>online</em> data, you will need MIDAS installed, and, if using the rootana system, <a href="https://bitbucket.org/tmidas/roody/src/master/">roody</a> is required for online histogram viewing.</p>
<h2><a class="anchor" id="download"></a>
Download and Compile</h2>
<p class="">One may obtain the analysis package from the <a href="https://github.com/DRAGON-Collaboration/analyzer">git repository</a> as follows:</p>
<pre class="fragment">mkdir -p ~/packages/dragon
cd ~/packages/dragon
git clone https://github.com/DRAGON-Collaboration/analyzer
cd analyzer
</pre><p class="">If you do not have git installed or prefer to download a tarball, then visit <a href="https://github.com/DRAGON-Collaboration/analyzer,">https://github.com/DRAGON-Collaboration/analyzer,</a> click on the <a href="https://github.com/DRAGON-Collaboration/analyzer/releases">releases link</a> and select the latest release (or an earlier one if you have reason to do so). Click on either the "zip" or the "tar.gz" link to download a zip file or a tarball containing the code.</p>
<p class="">Once the package is obtained, it is necessary to run a configure script in order to set the appropriate environment variables before compiling. To see a list of options, type:</p>
<pre class="fragment">./configure --help
</pre><p class="">In most cases, one may simply run</p>
<pre class="fragment">./configure
</pre><p class="">At this point, compilation <em>should</em> be as simple as typing <code>make</code>. If not, <a href="#" onclick="location.href='mai'+'lto:'+'dco'+'nn'+'oll'+'y@'+'tri'+'um'+'f.c'+'a'; return false;">please let me know</a>, and we can try to fix the problem permanently so others do not run into it.</p>
<p class="">Compilation creates a shared library <code>lib/libDragon.so</code> (and <code>lib/libDragon.so.dSYM</code> if installed on a Mac) as well as an executable <code>bin/mid2root</code>. The executable converts MIDAS files to ROOT trees. The library can be loaded into an interactive ROOT session by issuing the following commands:</p>
<pre class="fragment">root[] .include ~/packages/dragon/analyzer/src
root[] gSystem-&gt;Load("~/packages/dragon/analyzer/lib/libDragon.so");
</pre><p class="">It is strongly suggested that you add the appropriate lines to your root logon script if you have one. If you do not, the <a href="https://root.cern.ch/root/htmldoc/guides/users-guide/ROOTUsersGuide.html#environment-setup">proper way to set up your root environment</a> is to create a file entitled <code><a class="el" href="rootlogon_8_c.html" title="Example ROOT startup script.">rootlogon.C</a></code> in a sensible place (such as <code>~/packages/root/macros</code>) and include the following lines in it:</p>
<div class="fragment"><div class="line">gInterpreter-&gt;AddIncludePath(gSystem-&gt;ExpandPathName(<span class="stringliteral">&quot;${HOME}/packages/dragon/analyzer/src&quot;</span>));</div><div class="line">gSystem-&gt;Load(<span class="stringliteral">&quot;${HOME}/packages/dragon/analyzer/lib/libDragon.so&quot;</span>);</div></div><!-- fragment --><p class="">Then create the file <code>${HOME}/.rootrc</code> (if it doesn't already exist) and include the following line in it:</p>
<div class="fragment"><div class="line">Rint.Logon: /path/to/your/rootlogon.C</div></div><!-- fragment --><p class="">Examples of <code><a class="el" href="rootlogon_8_c.html" title="Example ROOT startup script.">rootlogon.C</a></code> and <a href="https://github.com/DRAGON-Collaboration/analyzer/blob/master/script/.rootrc">.rootrc</a> are given in the <a href="https://github.com/DRAGON-Collaboration/analyzer/tree/master/script">script</a> directory. This will give you access to all of the dragon classes and functions in the software package from within a ROOT session or macro.</p>
<p class="">If you are using git and want to stay on top of new releases, just do:</p>
<pre class="fragment">git pull master --tags
</pre><p class="">from within the repository directory (<code>~/packages/dragon/analyzer</code>). This gets you all of the new code since your last pull (or the initial clone). Note that we have started using a versioning system than goes as such: vMAJOR.MINOR.PATCH, where a MAJOR version change indicates a new set of <em>non backwards compatible</em> changes. MINOR indicates a feature addition that is still backwards compatible, and PATCH indicates a bugfix or other small change that is backwards compatible.</p>
<h2><a class="anchor" id="pyext"></a>
Python Extension</h2>
<dl class="section note"><dt>Note</dt><dd>No one has kept up with maintaining the python extension in quite a while and it is not a priority. Really, it was just a "fun" project to play around with using <code>Py++</code> and <code>Boost.Python</code>, but it should not take too much to get it running again if anyone is interested...</dd></dl>
<p>If you wish to compile or use the optional (and somewhat experimental) python extension, you will first need to install the <code>Boost.Python</code> library. For information on this, see: <a href="http://www.boost.org/doc/libs/1_66_0/libs/python/doc/html/index.html">http://www.boost.org/doc/libs/1_66_0/libs/python/doc/html/index.html</a></p>
<p class="">The python libraries rely on code generated by <a href="http://pyplusplus.readthedocs.io/en/latest/index.html"><code>Py++</code></a>, which parses the source files and generates code to be compiled into the python libraries. It should not be necessary to generate the source code yourself using Py++, as long as the repository is kept up-to-date; however,if you make changes to the dragon analyzer sources, re-generation of the Py++ sources will be necessary in order to safely use the python libraries.</p>
<p class="">To compile the python extension, simply <code>cd</code> into the py++ directory and type <code>make</code>, <em>after</em> having compiled the core dragon library. To be able to use the extensions from any directory, add the following to your bash startup script (e.g. - <code>~/.bashrc</code>):</p>
<div class="fragment"><div class="line">export PYTHONPATH=${PYTHONPATH}:<span class="stringliteral">&quot;$HOME/packages/dragon/analyzer/py++/&quot;</span></div><div class="line">export DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH:<span class="stringliteral">&quot;$HOME/packages/dragon/analyzer/py++/&quot;</span></div></div><!-- fragment --><p class="">and re-start your bash session or re-source the startup script. Now from a python session or script, you can load the generated modules:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> <a class="code" href="namespacemidas.html">midas</a></div><div class="line"><span class="keyword">import</span> <a class="code" href="namespacevme.html">vme</a></div><div class="line"><span class="keyword">import</span> <a class="code" href="namespacedragon.html">dragon</a></div></div><!-- fragment --><p class="">You can use the python 'help' function (<code>help dragon</code>, etc) to see the classes and functions available in each module.</p>
<h1><a class="anchor" id="using"></a>
For Users</h1>
<h2><a class="anchor" id="rootana"></a>
Rootana Online Analyzer</h2>
<p class="">This package includes a library to interface the DRAGON analysis codes with MIDAS's <a href="https://bitbucket.org/tmidas/rootana">rootana</a> system, which allows visualization of online and offline data in histograms. If you are familiar with the "old" DRAGON analyzer, this is essentially the same thing, but with a few added features. To use this analyzer, simply compile with the "USE_ROOTANA" option set to "YES" in the Makefile (of course, for this to work, you will need to have the corresponding MIDAS packages installed on your system). Then run the <code>anaDragon</code> executable, either from a shell or by starting it on the MIDAS status page. To see a list of command line option flags, run with the <code>-h</code> flag. To view histograms, you will need to run the 'roody' executable, which should be available on your system if you have MIDAS installed.</p>
<p class="">As mentioned, there are a couple feature additions since the previous version of the DRAGON analyzer. The main one is the ability to define histograms and cuts at run-time instead of compile time. The hope is that this will allow for easy and quick changes to be made to the available visualization, even for users who are completely inexperienced with C++.</p>
<p class="">Histograms are created at run-time (<code>anaDragon</code> program start) by parsing a text file that contains histogram definitions. By default, histograms are created from the file <code>$DRAGONSYS/histos.dat</code>, where <code>$DRAGONSYS</code> is the location of the DRAGON analyzer package. However, you can alternatively specify a different histogram definition file by invoking the <code>-histos</code> flag at program start:</p>
<pre class="fragment">./anaDragon -histos my_histograms.dat
</pre><p class="">Note that the default histogram file (or the one specified with the <code>-histos</code> flag, creates histograms that are available both online and offline, that is, they are viewable online using the roody interface, and they are also saved to a .root file at the end of the run. It is also possible to specify a separate set of histograms for online viewing <em>only</em>. To do this, invoke the <code>histos0</code> flag:</p>
<pre class="fragment">./anaDragon -histos0 histograms_i_only_care_to_see_online.dat
</pre><p class="">Now that you know how to specify what file to read the histogram definitions from, you should probably also know how to write said file. The basic way in which the files are parsed is by using a set of "key" codes that tell the parser to look in the lines below for the appropriate information for defining the corresponding ROOT object. The "keys" available are as follows:</p><ol type="1">
<li>DIR: Create a directory.<br />
 The succeeding line should contain the full path of the directory as plain text.<br />
 For example: <div class="fragment"><div class="line">DIR:</div><div class="line">    histos/gamma</div></div><!-- fragment --> This would create a new directory "histos", with "gamma" as a sub-directory. Note that if you later do <div class="fragment"><div class="line">DIR:</div><div class="line">    histos/hion</div></div><!-- fragment --> the "histos" directory would not be re-created; instead, "hion" would be added as a new sub-directory. When you specify a directory, any histogram definitions succeeding it will be members of that directory, until another directory line is encountered. If any histograms are defined before the first "DIR:" command, they will belong to the "top level" directory (e.g. in a <code>TFile</code>, their owning directory will be the <code>TFile</code> itself). <br />
<br />
</li>
<li>TH1D: Create a 1d histogram.<br />
 Should be succeeded by two lines:<br />
 1) the argument to a <code>TH1D</code> constructor <br />
 2) the parameter to display in the histogram.<br />
 Example: <div class="fragment"><div class="line">TH1D:</div><div class="line">  (<span class="stringliteral">&quot;bgo_e0&quot;</span>, <span class="stringliteral">&quot;Bgo energy, channel 0 [singles]&quot;</span>, 256, 0, 4096)</div><div class="line">    rootana::gHead.bgo.ecal[0]</div></div><!-- fragment --> (note that the indentations are only for readability, not required). This creates a histogram with name "`bgo_e0`", title "Bgo energy, channel 0 [singles]", and ranging from 0 to 4096 with 256 bins. The parameter to be displayed in the histogram would be <code>rootana::gHead.bgo.ecal[0]</code>. <br />
<br />
</li>
<li>TH2D: Create a 2d histogram.<br />
 Succeeding lines are in the same spirit as the 1D case, except a third line is added to specify the y-axis parameter. <br />
 Example: <div class="fragment"><div class="line">TH2D:</div><div class="line">    (<span class="stringliteral">&quot;bgo_e1_e0&quot;</span>, <span class="stringliteral">&quot;Bgo energy 1 vs. 0 [coinc]&quot;</span>, 256, 0, 4096, 256, 0, 4096)</div><div class="line">    rootana::gCoinc.head.bgo.ecal[1]</div><div class="line">    rootana::gCoinc.head.bgo.ecal[0]</div></div><!-- fragment --> Creates a histogram of <code>rootana::gCoinc.head.bgo.ecal[1]</code> [x-axis] vs. <code>rootana::gCoinc.head.bgo.ecal[0]</code> [y-axis]. <br />
<br />
</li>
<li>TH3D Create a 3d histogram.<br />
 Following the same pattern as 1d and 2d - add a third line to specify the z-axis parameter. <br />
<br />
</li>
<li>SCALER: Create a "scaler" histogram, that is a 1d histogram whose x-axis represents event number and y-axis represents number of counts (basically, abuse histogram to make it into a bar chart). <br />
 The lines following a "SCALER:" command are: <br />
 1) Constructor for a 1D histogram, which defines the x-axis (event) range and binning. Typically you want to start at zero and bin with 1 bin per channel. Note that the histogram will automatically extend itself if the number of events exceeds the x-axis range. <br />
 2) The scaler parameter you want to histogram. <br />
 Example: <div class="fragment"><div class="line">SCALER:</div><div class="line">    (<span class="stringliteral">&quot;rate_ch0&quot;</span>, <span class="stringliteral">&quot;Rate of scaler channel 0&quot;</span>, 5000, 0, 5000);</div><div class="line">    rootana::gHeadScaler.rate[0]</div></div><!-- fragment --> <br />
</li>
<li>SUMMARY: Create a "summary" histogram, that is a histogram which displays information on multiple channels at once, like this: <br />
 <div class="image">
<img src="summary.png" alt="summary.png"/>
</div>
 <br />
 Note that summary histograms are currently only available for arrays, that is, where each y-axis bin corresponds to a different array index. If you need to display summary information for parameters not contained in an array, you will have to define the histogram manually in C++. However, in nearly all cases where summary information might be desired, the parameters are already contained in an array anyway. <br />
 The lines following a "SUMMARY:" command are:<br />
 1) Constructor for a 1d histogram; this will define the x-axis binning and set the histogram name/title;<br />
 2) The name of an array that you want to display in the histogram;<br />
 3) The number of y-axis bins (should be equal to the length of the array).<br />
 Example: <div class="fragment"><div class="line">SUMMARY:</div><div class="line">    (<span class="stringliteral">&quot;bgo_q&quot;</span>, <span class="stringliteral">&quot;Bgo energies [singles]&quot;</span>, 256, 0, 4096)</div><div class="line">    rootana::gHead.bgo.ecal</div><div class="line">    30</div></div><!-- fragment --> This would create a summary histogram of the 30 BGO detector energies contained in the <code>rootana::gHead.bgo.ecal</code> array (<code>bgo.ecal[0]</code> &rarr; <code>bgo.ecal[29]</code>). <br />
<br />
</li>
<li>CUT: Defines a cut. <br />
 This defines a "cut" or "gate" condition that will be applied to the histogram defined directly before it. The cut condition is specified as a logical condition consisting of rootana::Cut derived classes. For more information on how to define a cut, see the code documentation of the Cut.hxx source file and links therein. As a simple example: <div class="fragment"><div class="line">TH1D:</div><div class="line">    (<span class="stringliteral">&quot;bgo_e0&quot;</span>, <span class="stringliteral">&quot;Bgo energy, ch 0 [singles]&quot;</span>, 256, 0, 4096)</div><div class="line">    rootana::gHead.bgo.ecal[0]</div><div class="line">CUT:</div><div class="line">    Less(gHead.bgo.ecal[0], 2000) &amp;&amp; Greater(gHead.bgo.ecal[0], 100)</div></div><!-- fragment --> will create the "bgo_e0" histogram displaying <code>bgo.ecal[0]</code>, with the condition that <code>bgo.ecal[0]</code> be greater than 100 and less than 2000. <br />
<br />
 Note that you can also create/use 2d polygon cuts, either by specifying the parameters and (closed) polygon points: <div class="fragment"><div class="line">CUT:</div><div class="line">    Cut2D(gHead.bgo.q[0], gHead.bgo.q[1], -2,-2, -2,2, 2,2, 2,-2, -2,-2)</div></div><!-- fragment --> This would create the following cut: <br />
 <div class="image">
<img src="cut.png" alt="cut.png"/>
</div>
 <br />
 It is also possible to pre-define and then re-use graphical cuts using the "CMD:" option (see next). <br />
<br />
</li>
<li>CMD: Evaluates a series of commands in CINT.<br />
 The succeeding lines are a series of C++ statements to be evaluated literally in the CINT interpreter, closed by a line containing only "END". Any objects created within these statements will become available for use in future commands throughout the definition file. Note that each file should only contain one "CMD:" statement (if it contains any), and that it should be the first "active" code within the file. As an example, we could use "CMD:" to define a graphical cut: <div class="fragment"><div class="line">CMD:</div><div class="line">  TCutG cutg(<span class="stringliteral">&quot;cutTest&quot;</span>,7);</div><div class="line">  cutg.SetVarX(<span class="stringliteral">&quot;&quot;</span>);</div><div class="line">  cutg.SetVarY(<span class="stringliteral">&quot;&quot;</span>);</div><div class="line">  cutg.SetTitle(<span class="stringliteral">&quot;Graph&quot;</span>);</div><div class="line">  cutg.SetFillColor(1);</div><div class="line">  cutg.SetPoint(0,37.8544,70.113);</div><div class="line">  cutg.SetPoint(1,25.5939,41.5819);</div><div class="line">  cutg.SetPoint(2,54.9042,28.0226);</div><div class="line">  cutg.SetPoint(3,83.0651,35.3672);</div><div class="line">  cutg.SetPoint(4,81.5326,53.1638);</div><div class="line">  cutg.SetPoint(5,59.3103,79.1525);</div><div class="line">  cutg.SetPoint(6,37.8544,70.113);</div><div class="line">END</div></div><!-- fragment --> This cut is then available in future statements; for example to create a Cut2D object to be applied to a histogram <div class="fragment"><div class="line">SUMMARY:</div><div class="line">  (<span class="stringliteral">&quot;bgo_ecal&quot;</span>, <span class="stringliteral">&quot;Bgo energies [singles]&quot;</span>, 256, 0, 4096)</div><div class="line">  rootana::gHead.bgo.ecal </div><div class="line">  30</div><div class="line">CUT:</div><div class="line">  Cut2D(gHead.bgo.ecal[0], gHead.bgo.ecal[1], cutg)</div></div><!-- fragment --> The above example would apply the graphical cut "cutg" defined in the "CMD:" statement to the "bgo_ecal" histogram.</li>
</ol>
<p class="">With combinations of the above commands, you should hopefully be able to define any histogram-related objects you will need in the online analyzer without ever having to touch the source code. A few more notes about histogram definition files:</p>
<ul>
<li>There are five global instances of "top-level" classes which encapsulate all of the relevant data in the experiment. Each class corresponds to a different event type, and is mapped to a different ROOT tree in the output file. As you may have noticed in the examples, these will need to prefix any parameters to be displayed in histograms. They are:<ol type="1">
<li><code>rootana::gHead</code> - "Head" (gamma) singles event</li>
<li><code>rootana::gTail</code> - "Tail" (heavy-ion( singles event</li>
<li><code>rootana::gCoinc</code> - Coincidence event</li>
<li><code>rootana::gHeadScaler</code> - "Head" (gamma) scaler event</li>
<li><code>rootana::gTailScaler</code> - "Tail" (heavy-ion) scaler event</li>
</ol>
</li>
<li>White-space is ignored, though good indention improves readability immensely. <br />
</li>
<li>The <code>#</code> character denotes a comment, all characters on the same line coming after a <code>#</code> are ignored: <div class="fragment"><div class="line"><span class="preprocessor"># IGNORE THIS HEADER STATEMENT #</span></div><div class="line"><span class="preprocessor">TH1D: #Ignore this descriptive comment also...</span></div></div><!-- fragment --></li>
<li>The run-time parsing is done using CINT via the <code>gROOT-&gt;ProcessLine()</code> and <code>gROOT-&gt;ProcessLineFast()</code> commands. These have very little native error handling. Some support has been added in the DRAGON analyzer to "gracefully" handle common errors when detectable; for example, skipping the current definition and moving onto others, but alerting the user. If you find a case where you feel the error handling could be improved (in particular, where a mistake in the script file causes a crash or un-reported failure), do not hesitate to alert the developers.</li>
</ul>
<p class="">Once started, the online analyzer simply runs in the background to receive, match, and analyze events coming from the two separate front-ends. The analyzed data are then summarized in the histograms requested by the user as outlined in the proceeding paragraphs. As mentioned, roody can be used to visualize the histograms as data is coming in. To start roody, you will need to specify the host and port of the histogram server. Usually this means, the following: </p><pre class="fragment">roody -Plocalhost:9091
</pre><p class="">if running locally from the back-end host, or </p><pre class="fragment">roody -Pdaenerys.triumf.ca:9091
</pre><p class="">if running remotely. Roody is a graphical program, and as such its use is fairly intuitive. When you start the program, you should see a graphical outline of the histograms and directory structure you created in your hist definitions file that looks something like this:</p>
<div class="image">
<img src="roody.png" alt="roody.png"/>
</div>
<p class="">Simply double click on a histogram icon, and a ROOT canvas will be created showing the histogram. You can play around with the menu bars to explore other options, such as canvas refresh rate and canvas configuration.</p>
<h1><a class="anchor" id="developers"></a>
For Developers</h1>
<p class="">This section just gives a brief overview behind the package's design and some suggestions for future maintainers/developers. For detailed documentation, see the related Doxygen documentation linked from the top of this page.</p>
<h2><a class="anchor" id="design"></a>
Design</h2>
<p class="">In writing this code, I have tried to adhere to a few design principles. I will give a brief listing here in hopes that future developers (or users) of the code can better understand what is going on and the reasoning behind it. In the future (barring a major re-write), I think it will be beneficial to follow a similar design pattern for modifications and updates to the code, if for no other reason than to keep a sense of uniformity which will hopefully facilitate understanding of the code. <br />
</p><ul>
<li><b>Separate the handling of "raw" data from that of abstract experiment parameters.</b> <br />
 By this I mean separating the "raw" tasks of reading data directly from VME modules from that of organizing the data into parameters which represent more abstract experimental quantities. As a simple example, separate the "raw" task of reading the conversion value of QDC channel 27 from the "abstract" task of realizing that this value corresponds to the energy deposited in BGO detector number 27. The hope is that by de-coupling the two different types of operations, we will gain greater flexibility and re-usability of the code. <br />
 To accomplish this, there are separate "vme" classes (under the <a href="namespacevme.html">vme namespace</a>) which handle the unpacking of raw vme data. Each vme class contains data fields to store its respective measurements. For example, see the documentation of <code><a class="el" href="classvme_1_1_v792.html">vme::V792</a></code>, which represents a CAEN V792 QDC module. <br />
<br />
</li>
<li><p class="startli"><b>Store abstract experiment parameters in classes which logically correspond to the separate pieces of a DRAGON experiment.</b> <br />
 The basic idea is that we want to take the important data captured during a DRAGON event and break it down into a tree-like structure. In general, each "branch" of the tree corresponds to a different detector within the DRAGON system, and the various "leaves" correspond to quantities measured by that detector. For example, see the <a class="el" href="classdragon_1_1_coinc.html">dragon::Coinc</a> documentation and the "Attribute" links therein. <br />
 Taking this approach allows a couple of practical advantages beyond code organization and maintenance. The main one is that we can use ROOT's dictionary facility to create <code>TTree</code>s whith branches defined by the structure of our classes. For example we can just do: </p><div class="fragment"><div class="line"><a class="code" href="classdragon_1_1_coinc.html">dragon::Coinc</a>* coinc = <span class="keyword">new</span> <a class="code" href="classdragon_1_1_coinc.html">dragon::Coinc</a>();</div><div class="line">TTree tcoinc(<span class="stringliteral">&quot;tcoinc&quot;</span>,<span class="stringliteral">&quot;Coincidence event&quot;</span>);</div><div class="line">tcoinc.Branch(<span class="stringliteral">&quot;coinc&quot;</span>,<span class="stringliteral">&quot;dragon::Coinc&quot;</span>,&amp;coinc);</div></div><!-- fragment --><p> After just a few lines of code, we now have the ability to access any parameter in a DRAGON coincidence event through the 'tcoinc' tree: </p><div class="fragment"><div class="line">tcoinc.Draw(<span class="stringliteral">&quot;coinc.head.bgo.ecal[0]&gt;&gt;hst_e0(400,0,4000)&quot;</span>); <span class="comment">// Draws BGO energy, channel 0</span></div><div class="line">tcoinc.Draw(<span class="stringliteral">&quot;coinc.tail.mcp.tac&gt;&gt;hst_tac(200,0,2000)&quot;</span>); <span class="comment">// Draws MCP TOF</span></div></div><!-- fragment --><p> In writing the DRAGON classes, I have not used any sort of inheritance, as there is really no compelling reason to do so (in particular, we have no need for dynamic polymorphism). I have, however, tried to maintain a uniform interface for each of the classes. For example, each detector class has the following three methods: <br />
</p><ol type="1">
<li><code>read_data()</code> - Takes raw data from vme module classes and maps it into the class's internal data structures.</li>
<li><code>calculate()</code> - Performs any necessary calculations on the raw data; for example, this could include things such as pedestal subtraction, channel calibration, or calculation of quantities which depend on multiple signals.</li>
<li><code>reset()</code> - Resets all of the class's internal data to a "default" throwaway value; in most cases this will be equivalent to <code>dragon::NO_DATA</code>.</li>
</ol>
<p class="startli"><br />
 Developing with a common interface, aside from being "neater" allows for some practical advantages, such as using template "helper" functions to bundle routines used for a variety of different classes. For example: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;</div><div class="line"><span class="keywordtype">void</span> handle_event(T&amp; detector, <span class="keyword">const</span> <a class="code" href="classvme_1_1_v792.html">vme::V785</a> adc[], <span class="keyword">const</span> <a class="code" href="classvme_1_1_v1190.html">vme::V1190</a>&amp; tdc)</div><div class="line">{</div><div class="line">    detector.reset();</div><div class="line">    detector.read_data(adc, tdc);</div><div class="line">    detector.calculate();</div><div class="line">}</div><div class="line">    </div><div class="line"><span class="keywordtype">void</span> handle_all_events()</div><div class="line">{</div><div class="line">    handle_event(mcp, adc, tdc); <span class="comment">// mcp is an instance of dragon::Mcp</span></div><div class="line">    handle_event(ic, adc, tdc); <span class="comment">// ic is an instance of dragon::IonChamber</span></div><div class="line">    <span class="comment">// ... etc ... //</span></div><div class="line">}</div></div><!-- fragment --><p> Another feature that I have adhered to is to allow class data members to be public. Although this goes against canonical object oriented good principles, I think the advantages outweight the disadvantages. This is particularly true if we are working in CINT to analyze data.<sup><a href="#footnotes"><b>1</b></a></sup> For example, with public data, it's trivial to loop over a tree, calculate some new parameter and display it in a histogram. For example, say I want to plot the square of MCP time-of-flight in cases where it is nonzero: </p><div class="fragment"><div class="line"><span class="comment">// Assume prior existance of a TTree &#39;t&#39; containing heavy-ion data</span></div><div class="line"><a class="code" href="classdragon_1_1_tail.html">dragon::Tail</a> tail;</div><div class="line"><span class="keywordtype">void</span>* tailAddr = &amp;tail;</div><div class="line">t-&gt;SetBranchAddress(<span class="stringliteral">&quot;tail&quot;</span>, &amp;tailAddr);</div><div class="line">TH1D hst(<span class="stringliteral">&quot;hst&quot;</span>, <span class="stringliteral">&quot;MCP Tof **2&quot;</span>, 100, 0, 10000);</div><div class="line"><span class="keywordflow">for</span>(Long64_t event = 0; <span class="keyword">event</span> &lt; t-&gt;GetEntries(); ++event) {</div><div class="line">    t-&gt;GetEntry(event);</div><div class="line">    <span class="keywordflow">if</span> (tail.<a class="code" href="classdragon_1_1_tail.html#a9c3c16512a9935af416570dfbd8df9f1">mcp</a>.<a class="code" href="classdragon_1_1_mcp.html#a645dd94598f93eee32666d9c95a7be4c">tac</a> &gt; 0) {</div><div class="line">    hst.Fill(pow(tail.map.tac, 2));</div><div class="line">    }</div><div class="line">}</div><div class="line">hst-&gt;Draw();</div></div><!-- fragment --><p> However, despite the usefulness of public data for scripting use, it is still a good idea to design the <em>source</em> code as if the data were private. This reduces the coupling between the various classes, and as a result making a small change to the structure of one class (or module) is guaranteed not to affect the others. To enforce this, I have defined a macro <code>PRIVATE</code> which can be set to be equal to either <code>private</code> or <code>public</code> in the Makefile and defined all of the class data members under this token. </p><div class="fragment"><div class="line"><span class="keyword">class </span>SomeDetector {</div><div class="line">PRIVATE:</div><div class="line">  <span class="keywordtype">double</span> some_parameter;</div><div class="line">  <span class="comment">// etc. //</span></div><div class="line">};</div></div><!-- fragment --><p> When developing the source code, one should make sure it will compile with PRIVATE=private - to enforce good class design. Then when set up for "production" mode, switch over to PRIVATE=public to allow direct variable access in CINT (and in the python modules, if used). <br />
</p>
</li>
<li><b>Add a layer of abstraction for commonly performed routines.</b> <br />
 For example, to read raw QDC data into the <code><a class="el" href="classdragon_1_1_bgo.html">dragon::Bgo</a></code> class, we <em>could</em> do: <br />
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classdragon_1_1_bgo.html#ad34cc52e906ac6e107bb00036d28fa9e">dragon::Bgo::read_data</a>(<span class="keyword">const</span> <a class="code" href="classvme_1_1_v792.html">vme::V792</a>&amp; adc, <span class="keyword">const</span> <a class="code" href="classvme_1_1_v1190.html">vme::V1190</a>&amp; tdc)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt; <a class="code" href="classdragon_1_1_bgo.html#a26eff3c3e01bfdab41631dc21bc8b871">MAX_CHANNELS</a>; ++i) {</div><div class="line">      <a class="code" href="classdragon_1_1_bgo.html#a9b383f00dbe02e48b2d5684f9b23901a">ecal</a>[i] = <a class="code" href="namespacevme.html">vme</a>.get_data(<a class="code" href="classdragon_1_1_bgo.html#af7bca8cedad161220e57c6940ec42b76">variables</a>.<a class="code" href="classdragon_1_1_bgo_1_1_variables.html#ac6b693a4da208351cf06532b00f51c49">adc</a>.<a class="code" href="namespacedragon_1_1utils.html#a7748b18220412d2f19532fd03e9bd3b8">channel</a>[i]);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> but instead we prefer to do the following, using <a class="el" href="namespacedragon_1_1utils.html#a14c7c20285926a9a018da79f8c76cd1d" title="Maps raw vme data into another array.">utils::channel_map()</a> to do the actual mapping. <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classdragon_1_1_bgo.html#ad34cc52e906ac6e107bb00036d28fa9e">dragon::Bgo::read_data</a>(<span class="keyword">const</span> <a class="code" href="classvme_1_1_v792.html">vme::V792</a>&amp; adc, <span class="keyword">const</span> <a class="code" href="classvme_1_1_v1190.html">vme::V1190</a>&amp; tdc)</div><div class="line">{</div><div class="line">  <a class="code" href="namespacedragon_1_1utils.html#a14c7c20285926a9a018da79f8c76cd1d">utils::channel_map</a>(<a class="code" href="classdragon_1_1_bgo.html#a9b383f00dbe02e48b2d5684f9b23901a">ecal</a>, <a class="code" href="classdragon_1_1_bgo.html#a26eff3c3e01bfdab41631dc21bc8b871">MAX_CHANNELS</a>, <a class="code" href="classdragon_1_1_bgo.html#af7bca8cedad161220e57c6940ec42b76">variables</a>.<a class="code" href="classdragon_1_1_bgo_1_1_variables.html#ac6b693a4da208351cf06532b00f51c49">adc</a>.<a class="code" href="namespacedragon_1_1utils.html#a7748b18220412d2f19532fd03e9bd3b8">channel</a>, adc);</div><div class="line">}</div></div><!-- fragment --> The main motivation for this is to concentrate the majority of the "heavy lifting" used in various calculations into one place. This helps to reduce the occurrence of bugs due to re-writing of similar code, and if bugs are found to facilitate easier fixes. Most of the "heavy lifting" is done in free functions contained in the <code><a class="el" href="namespacedragon_1_1utils.html" title="Encloses various &#39;utility&#39; functions.">dragon::utils</a></code> namespace, or using <a href="http://www.cplusplus.com/reference/algorithm/">standard library algorithms</a>.</li>
</ul>
<h2><a class="anchor" id="conventions"></a>
Coding Conventions</h2>
<p class="">Finally, there are a few stylistic issues to address. Much of this is just preference, but it would be nice to keep consistency in future code.</p>
<ul>
<li>Make use of namespaces to logically group related classes together. For example, all classes representing vme modules are under the <a href="namespacevme.html">vme namespace</a>, all classes representing dragon detectors or collections of detectors are under the <a href="namespacedragon.html"><code>dragon</code></a> namespace, all midas-related stuff under the <a href="namespacemidas.html"><code>midas</code></a> namesapce and so on. Source files belonging to a common namespace are grouped into the same subdirectory within <code>src/</code>.</li>
<li>Class names generally start with a capitol letter and use "CamelCase" when consisting of multiple words. Acronyms are not treated any differently, to avoid confusion; for example <code>class Dsssd</code> <em>not</em> <code>class DSSSD</code>.</li>
<li>Class methods and free functions are all "CamelCase" (including acronyms) (<code>SomeMethod</code> or <code>SomeFunction</code> or <code>SomeMthd</code>).</li>
<li>Brackets: for everything except function definitions, keep the opening bracket on the same line and the trailing bracket on a new line: <br />
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacedragon.html">dragon</a> {</div><div class="line"></div><div class="line"><span class="keyword">class </span>Bgo {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classdragon_1_1_bgo.html#a684f0cc5fb67399e25b04845f98fb8bb">calculate</a>();</div><div class="line">    <span class="comment">// ... //</span></div><div class="line">};</div><div class="line">} <span class="comment">// namespace dragon</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classdragon_1_1_bgo.html#a684f0cc5fb67399e25b04845f98fb8bb">dragon::Bgo::calculate</a>()</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="classdragon_1_1_bgo.html#a26eff3c3e01bfdab41631dc21bc8b871">MAX_CHANNELS</a>; ++i ) {</div><div class="line">    <span class="comment">// ... //</span></div><div class="line">    }</div><div class="line"><span class="comment">// ... //</span></div><div class="line">}</div></div><!-- fragment --></li>
<li>In any class that might be parsed into a tree structure using rootcint, class members are all lowercase, should be descriptive yet brief when parsing classes into a tree structure, and should <em>not</em> use any form of Hungarian notation (as it will conflict with the "nicely descriptive" requirement). This has a practical advantage when we let ROOT parse our classes into a <code>TTree</code>: the brach names make sense and are logical. I would much rather type: <br />
<div class="fragment"><div class="line">t-&gt;Draw(<span class="stringliteral">&quot;head.bgo.ecal[0]&quot;</span>);</div></div><!-- fragment --> than <br />
<div class="fragment"><div class="line">t-&gt;Draw(<span class="stringliteral">&quot;gHead.fBgo.fEnergy[0]&quot;</span>); <span class="comment">// (following the ROOT / Taligent convention)</span></div></div><!-- fragment --> For classes that are not intended to be made <code>TTree</code> branches, the ROOT/Taligent hungarian notation can be quite nice, however. <br />
</li>
<li>Whenever appropriate, prefer arrays to separate variables. For example, BGO energies are defined as <br />
<div class="fragment"><div class="line"><span class="keywordtype">double</span> ecal[MAX_CHANNELS];</div></div><!-- fragment --> instead of <div class="fragment"><div class="line"><span class="keywordtype">double</span> ecal0;</div><div class="line"><span class="keywordtype">double</span> ecal1;</div><div class="line"><span class="comment">// ... //</span></div><div class="line"><span class="keywordtype">double</span> ecal29;</div></div><!-- fragment --> This has a number of practical advantages, such as allowing for loops and std::algorithms to handle the data, and in general it makes life much easier in later analyses as well. It also avoids any issues about whether to start counting at one or zero, since arrays always start from zero.</li>
</ul>
<h2><a class="anchor" id="doc"></a>
Documentation</h2>
<p class="">Given the fast turnover rate of developers and the common requirement for "everyday" users (whose level of expertise in the source language ranges from beginner to expert) to understand and modify source code, maintaining quality code documentation is essential for a physics software package to stay maintainable.</p>
<p class="">As you may have noticed, the present source code has been extensively documented using <a href="http://doxygen.org">Doxygen</a>. I do not claim that the present documentation is perfect by any means, but I hope it is at least a large step in the right direction. If you happen to extend or modify the code base, <em>please carefully document anything that you do.</em> If you are not familiar with Doxygen, it is quite intuitive and quick to learn - just follow the example of existing code and/or refer to the <a href="http://www.stack.nl/~dimitri/doxygen/manual/index.html">Doxygen manual</a>.</p>
<h1><a class="anchor" id="footnotes"></a>
Footnotes</h1>
<p class=""><sup>1</sup>Actually, because the dictionary file generated by rootcint uses the <code>#define private public</code> trick to gain access to your class's internals, if you <em>don't</em> make all of your class data public you actually end up generating code that is not within the C++ standard and, in theory at least, can lead to undefined behavior! See, for example, <a href="http://www.gotw.ca/gotw/076.htm"><b>this link</b></a> for more on this subject. So, if you want to be as standards compliant as possible, you will have to make all of your class members public. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 24 2018 21:18:41 for DRAGON Analyzer by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
