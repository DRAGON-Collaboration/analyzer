///
/// \file RootAnalysis.hxx
/// \author G. Christian
/// \brief Defines classes and utilities to help in analysis of ROOT
///  files generated by `mid2root`.
///
#ifndef DRAGON_ROOT_ANALYSIS_HEADER
#define DRAGON_ROOT_ANALYSIS_HEADER
#ifdef USE_ROOT
#include <map>
#include <TFile.h>
#include <TTree.h>
#include <TString.h>


namespace dragon {

/// Filters a TChain based on some cut condition
class TTreeFilter {
public:
	struct Out_t {
		TTree* fTree;
		TString fCondition;
	};
	typedef std::map <TTree*, Out_t> Map_t;
	typedef std::pair<TTree*, Out_t> Pair_t;
private:
	/// No copy
	TTreeFilter(const TTreeFilter&) { }
	/// No assign
	TTreeFilter& operator= (const TTreeFilter&) { return *this; }
public:
	/// Ctor
	TTreeFilter(const char* filename);
	/// Ctor
	TTreeFilter(TDirectory* output);
	/// Dtor
	~TTreeFilter();
	/// Check if the filter condition is valid.
	Bool_t CheckCondition(TTree* tree) const;
	/// Close the output directory (if the owner)
	void CloseOutDir();
	/// Check if we're the file owner
	Bool_t IsFileOwner() const { return fFileOwner; }
	/// Get filter condition
	const char* GetFilterCondition(TTree* tree) const;
	/// Check if running threaded version or not.
	Bool_t GetThreaded() const { return fRunThreaded; }
	/// Get output directory
	TDirectory* GetOutDir() const { return fDirectory; }
	/// Do the filtering
	Int_t Run();
	/// Set a tree to filter and it's filter condition
	void SetFilterCondition(TTree* tree, const char* condition);
	/// Set output directory
	void SetOutDir(TDirectory* directory);
	/// Turn on/off threading for different trees, default is on
	void SetThreaded(Bool_t on);
	/// Check if output directory is valid.
	Bool_t IsZombie() const;
private:
	/// Use separate threads for each tree?
	Bool_t fRunThreaded;
	/// File (directory) owning the output tree
	TDirectory* fDirectory;
	/// Do we take ownership of fFile or not?
	Bool_t fFileOwner;
	/// The input trees and conditions
	Map_t fInputs;
};

} // namespace dragon


#endif // USE_ROOT
#endif // Include guard
